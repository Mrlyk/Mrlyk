# react diff 算法

这里详细记录一下 react 的 diff 算法，看一下 react 的虚拟 dom 是如何更新的！

[toc]

传统的 diff 算法复杂度是O(n^3），react 经由以下三点将复杂度降低到了 O(n)

- **tree diff**：在两个树对比时，只会比较同一层级的节点，会忽略掉跨层级的操作
- **component diff**：在对比两个组件时，首先会判断它们两个的类型是否相同，如果不同则不会进一步向下比较，会直接销毁组件，创建新的组件插入。
- **element diff**：对于同一层级的一组节点，会使用具有唯一性的key来区分是否需要创建，删除，或者是移动。



## react diff 算法源码解读





## react diff vs vue diff

#### vue的diff算法

- vue中的节点对比采用双指针，从两端向中间遍历，当指针交叉的时候，就是对比完成了
- 开始遍历时，首先依次进行头头、尾尾、头尾、尾头对比，这也是vue中diff算法 的一个优化点
- 都对比完了，再对比其他没有移动规律的节点

简单来说，就是vue的diff算法在对新老虚拟 dom 进行对比时，是从节点的两侧向中间对比；如果节点的key值与元素类型相同，属性值不同，就会认为是不同节点，就会删除重建

#### react的diff算法

- 只对同级节点进行对比，如果DOM节点跨层级移动，则不复用

- 用key来构建一个老节点的map，复用一个后要从map里删除

- `lastPlacedIndex` 表示最后一个不需要移动的节点的索引

- 移动时的原则是尽量少量的移动，如果必须有一个要动，新地位高的不动，新地位低的动


##### 对比顺序

1. 如果可以找到key对应的节点，再对比类型，如果类型不同，就删除旧节点重新创建，
2. 类型相同，对比 lastPlacedIndex 与 oldIndex，lastPlacedIndex <= oldIndex 不需要移动，否则就需要移动位置，并且更新属性

##### 修改dom的顺序

1. 删除
2. 更新与移动
3. 插入操作

#### 两种 diff 算法的相同点

- 都是两组虚拟 dom 的对比(react16.8之后是fiber与虚拟dom的对比)
- 只对同级节点进行对比，简化了算法复杂度
- 都用 key 做为唯一标识，进行查找，只有 key 和标签类型相同时才会复用老节点
- 遍历前都会根据老的节点构建一个 map，方便根据 key 快速查找

#### 两种 diff 算法的不同点

- react在 diff 遍历的时候，只对需要修改的节点进行了记录，形成 effect list，最后才会根据 effect list 进行真实 dom 的修改，修改时先删除，然后更新与移动，最后插入
- vue 在遍历的时候就用真实 dom`insertBefore`方法，**修改了真实dom，最后做的删除操作**
- **react 采用单指针从左向右进行遍历**
- **vue 采用双指针，从两头向中间进行遍历**
- **react 的虚拟diff比较简单，vue中做了一些优化处理，相对复杂，但效率更高**



## 参考文章

为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？：https://juejin.cn/post/7116141318853623839

React源码揭秘 diff 算法详解：https://juejin.cn/post/6844904167472005134
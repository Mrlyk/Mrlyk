# webpack 属性解析

[toc]

## output 打包输出

#### .library / .libraryTarget / .libraryExport

主要用来处理打包一个库的时候。webapck 编译后，module.exports 导出的对象会被挂到一个叫 _entry_return_ 的变量下。webapck 官网给出的解释如下：

```text
Note that_entry_return_is the value returned by the entry point. In the bundle itself, it is the output of the function that is generated by webpack from the entry point.
```

**library**

可以用它来指定导出的包名，如下

```text
module.exports = {
  //...
  output: {
    library: 'MyLibrary',
    // libraryTarget: 'var'
  }
};
```

它的用途需要根据 `libraryTarget` 来确定，默认情况下 `libraryTarget` 的值为 `var`，上面的代码经过编译后如下：

```text
var MyLibrary = _entry_return_; // _entry_return_ 代表 webapck 编译所返回的产物
```

**libraryExport**

用它来指定你需要导出的模块内容。

可以使用 libraryExport 来指定具体需要导出的部分

```text
module.exports = {
  //...
  output: {
    library: 'MyLibrary',
    libraryExport: ['func', 'a']
    libraryTarget: 'var'
  }
};
```

经过编译，它最终是这样：

```text
var MyLibrary = _entry_return_.func.a; // 导出 a 函数赋值给 MyLibrary
```

它可以有四种值：

1. `libraryExport: undefined `不设置或者 libraryTarget 的值为 ''，它的值为 undefined
2. `libraryExport: 'default'`
3. `libraryExport: 'MyModule' `使用自定义 name 导出
4. `libraryExport: ['MyModule', 'MySubModule'] `使用多个自定义 name 导出

上面四种情况编译后得到的编译结果分别如下

```text
1、var MyLibrary = _entry_return_ // 会暴露整个打包后得到的 bundle 中导出的内容
2、var MyLibrary = _entry_return_.default
3、var MyLibrary = _entry_return_.MyModule
4、var MyLibrary = _entry_return_.MyModule.MySubModule 
```

**libraryTarget**

string | object (webpack 3 +)

1. var - 默认值 ，var MyLibrary = _entry_return_; 
2. assign - MyLibrary = _entry_return_ 全局变量，可能导致全局污染
3. this - this["myDemo"] = _entry_return_; this 由用户决定
4. window - window['MyLibrary'] = _entry_return_ 浏览器环境
5. global - global['MyLibrary'] = _entry_return_ node 环境
6. commonjs - exports['MyLibrary'] = _entry_return_ 
7. commonjs2 - module.exports = _entry_return_; 普通的commonjs不能用于 node 或其他 cjs 的派生规范，这个可以
8. amd - amd 规范导出
9. umd - amd 和 cjs 兼容
10. jsonp - jsop 的方式

**main / module / browser**

- webpack 选择 web 浏览器环境

- - 插件的 package.json 是否配置了 browser 字段

  - - 存在：选择 browser 作为入口

    - 不存在：

    - - 插件的 package.json 是否配置了 module 字段

      - - 存在：选择 module 作为入口
        - 不存在：以 main 作为入口

- webapack 选择 node环境

- - 插件的 package.json 是否配置了 module 字段

  - - 存在：选择 module 作为入口
    - 不存在：以 main 作为入口

#### output.environment 配置 webpack 自身的打包产物的一些规则

webpack 自身打包默认行为是不受 babel 影响的，babel 智能处理我们自己项目中的代码。比如默认将产物全部包裹在箭头函数中而不是普通函数是 webpack 打包的默认行为，会导致 IE11 无法运行（即使 babel 配置了）。

```js
// 配置产物的运行环境，默认产物会被包裹在箭头函数中，导致在 IE11 中仍然不能执行
{
  environment: {
    arrowFunction: false, // 关闭箭头函数，使用普通的函数方法
    const: false // 关闭 const
  },
}    
```

#### output.path & output.publicPath & devServer.static.publicPath & HtmlWebpackPlugin.publicPath

这里区分几个不同的 path 作用，平常使用的时候很容易搞混

1. output.path：定义打包产物的输出路径，指的是硬盘上真实的路径
2. output.publicPath：定义 webpack-dev-server 和打包产物中`<script>`标签引入文件的相对路径（相对的是当前访问的域名对应的根目录）。如下

```js
{
  output: {
    publicPath: '/public/' // 默认是"/"
  }
}
// 在产物的 index.html 中，引入的路径就是 <script src="/public/bundle.js">，带上 /public/ 前缀.
// 最终访问页面，页面去加载资源的时候就是 https://xxxx/public/bundele.js
```

**这里要注意几点：**

- webpack server 本身可以在 devServer 中配置自己的 publicPath，**具有更高的优先级**
- webpack server 如果在 devServer 中没有单独配置，则会读取 output 中的这个配置，webpack server 运行产生的文件是在内存中我们看不见。如果配置了之后去访问项目的时候就要带上这层路径才能到内存中的真正目录`http://localhost:8080/public`
- output.publicPath 和 output.path 没什么关系，在开发中只启动 server 服务的话甚至可以不配置 path

3. devServer.static.publicPath：webpack 5 变更的，在webpack4 中就是 devServer.publicPath，**webpack server 中静态资源文件的加载地址**

```js
{
  devServer: {
    static: {
      publicPath: '/public/' // webpack server 引入的静态资源文件的加载地址，会覆盖 output 中 publicPath 的设置
    }
  }
}
// 直接在 index.html 中手动引入文件 <script src='/public/js/test.js'></script> 这种静态资源文件
// 如果 devServer 中配置的 publicPath 错误，会导致无法加载这个静态资源文件 404
```

**另外像一些自己的纯静态文件，不需要参与打包的。应该使用`CopyWebpackPlugin`拷贝到输目录，而不是在这几个 path 这里纠结。**

#### sourceMapFilename

定义代码映射的文件名称，只在`devtool`启用了 SourceMap 选项时才使用。

```js
{
  output: {
    sourceMapFilename: '[file].[chunkhash:8].map'
  }
}
```

## context 定义基础路径

entry、loader 等的所有相对路径都是相对于这个路径而言的，默认是当前 node 工作的路径

```js
{
  context: '/root'
  // context: process.cwd() // 当前 node 流程所在的工作目录
}
```

## stats 输出信息控制

使用 webpack 打包或者启动 devServer 的时候控制台总是输出一大堆信息。可以配置该选项来控制输出的信息数据

官方文档：https://webpack.docschina.org/configuration/stats/

```js
module.exports = {
  stats: 'errors-only', // 仅输出错误信息
  // stats: { // 单独关闭资源文件信息输出
    // assets: false,
  // },
}
```

- 'errors-warnings': 输出错误和警告信息

在 webpack 5 之前一般使用`friendly-errors-webpack-plugin`来控制，**在 webpack 5 中该插件无法覆盖 webpack 5 的配置，还是会有信息输出，需要配合此选项一起使用才行**  

## module 定义如何处理项目中的模块

```js
{
  module: {
    // 定义模块的处理规则
    rules: [
      {
        test: /\.js$/, // 匹配文件
      	use: 'babel-loader' // 使用的 loader
      }
    ]
  }
}
```

#### rules 中的配置

**use 和 loader**

use 接收一个数组，可以配置多个 loader，顺序是定义在后面的先使用
**loader 是 use 的别名**，在高版本 webpack 中已经废弃，尽量不要使用

```js
use: [
  'style-loader',
  {
    loader: 'css-loader',
    options: {
      importLoaders: 1
    }
  },
  {
    loader: 'less-loader',
    options: {
      noIeCompat: true
    }
  }
]
```

**oneof** 

匹配其中一个，详见《常用优化方式》

```js
{
  test: /.css$/,
  oneOf: [
    {
      resourceQuery: /inline/, // foo.css?inline
      use: 'url-loader'
    },
    {
      resourceQuery: /external/, // foo.css?external
      use: 'file-loader'
    }
  ]
}
```



## resolve 定义如何解析项目中的模块文件

#### alias 别名



#### symlinks 定义从真实路径读取文件

处理引入的软连接问题

#### extensions 定义哪些扩展名的文件会被解析

默认值是 ['.wasm', '.mjs', '.js', '.json']，所以如果要接戏 TS 文件就需要我们手动声明，注意这里会直接覆盖默认值。

#### mainFiles 定义目录下的主文件

定义默认获取目录下的哪个文件，默认是 [index]

比如` import XX from './test'`，如果 test 是目录会尝试获取`'./test/index'`

```js
module.exports = {
  // ...
  resolve: {
    mainFiles: ["index", "view"]
  }
  // ...
}
```

## devtool 定义代码映射

官方文档：https://webpack.js.org/configuration/devtool/

在 devtool 属性中，我们可以配置代码的映射方法。让我们能在某些环境下看到真正的代码位置，而不是混淆压缩过的。

```js
{
  devtool: 'source-map'
}
```

## devServer

webpakc-dev-server 内置服务器

```js
module.exports = {
  devServer: {
    host: '0.0.0.0', // 启动的主机地址，如果为域名需要域名能解析到本机或配合修改 host 使用
    port: '8080', // 启动端口
    allowedHosts: 'all', // ！！！允许映射的域名，不开启的话修改本机 host 映射本机域名时无法访问：Invalid Host header
    historyApiFallback: true, // 未匹配到页面时回腿到 index.html ，对单页应用很有效
    proxy: {
      '/api': {
        changeOrigin: true, // target是域名的话，需要这个参数，
        target: `http://xxxx:8800`, // 路径代理，规则和 ng 的不一样，无论有没有 / 默认都是拼接到后面
        pathRewrite: {
          '/api/': '' // 重写路径，把 api 这个去除，否则请求到时候会带上这一层。不重写 /api/test -> http://xxxx:8800/api/test ；重写 /api/test -> http://xxxx:8800/test
        }
      }
    }
  }
}
```

## plugins 插件

#### HotModuleReplacementPlugin 热更新

热加载插件

```js
const WBP = require('webpack')

{
  plugins: [
    new WBP.HotModuleReplacementPlugin() 
  ]
}
```

如果要自己实现代码热更新可以看看热更新的原理（通过暴露的 module.hot 对象）

热更新参考文章：https://zhuanlan.zhihu.com/p/52465785

#### NoEmitOnErrorsPlugin 不生成异常产物

构建发生错误时不生成产物的插件，防止将含有异常代码的文件生成

```js
const WBP = require('webpack')

{
  plugins: [
    new WBP.NoEmitOnErrorsPlugin() 
  ]
}
```

## resolveLoader loader 解析地址

用于告诉 webpack 去哪些路径寻找 loader

默认 modules 是`node_modules`，扩展名是`.js\.json` 

```js
// webapck.config.js
module.exports = {
  resolveLoader: {
    modules: [
      'node_modules',
      path.resolve(__dirname, 'loaders')
    ]
  }
}
```

## externals 外部扩展

其中声明的包将不会被打包进入 bundle

```js
{
  externals: {
      jquery: 'jQuery',
      lodash : {
    		commonjs: "lodash", // 在 CommonJs 中通过 lodash 访问
    		amd: "lodash", // 在 AMD 规范中通过 lodash 访问
    		root: "_" // 指向全局变量
  		}
  }
}

// 使用
import $ from 'jquery' // 注意这里引入的包名称对应的是 externals 中的 key， value 是包 export 的对象

```

## sideEffects 副作用标记 tree-shaking

webpack@^4 在`mode`为`production`情况下默认开启 tree-shaking，原理可以查看自己的 tree-shaking 文章。总之是借助 ESM 的特性来实现，CJS 是不行的。

但一般我们的项目各种模块规范混用的，所以会存在一个问题就是 webpack 不能判断依赖中的某个方法是否具有副作用（即引入时就触发的单方面的影响，比如直接在 `window`上挂载了）导致 webpack 不敢直接 shaking 掉。

我们可以通过`sideEffects`字段声明项目中的模块不存在这种副作用

```js
module.exports = {
  // ...
  sideEffects: false, // 表明项目中所有的模块都没有副作用
  sideEffects: ['./src/view/test.js'] // 表明 test.js 没有副作用
}
```

*注意：直接全局开启会带来一些影响，如有的第三方模块确实存在副作用，但是被 shaking 掉了*

## optimization 优化策略

#### minimize

当我们设置了 webpack 的 mode 属性时，会根据不同的属性 webpack 自动做一些优化。比如`mode: production`的时候，会通过 tree-shaking 把我们所有的`console.log`删掉。如果我们不想这么做，就可以在这里配置优化策略以覆盖原来的策略。

```js
// webpack.config.js
const TerserPlugin = require("terser-webpack-plugin"); // TerserPlugin webpack内置了，但是想自定义配置还是需要另外安装

module.exports = {
  ...
  optimization: {
    minimize: true, // 默认 true ，是否使用 TerserWebpackPlugin 压缩代码。开启后下面的 minimizer 才会生效
    minimizer: [
      new TerserPlugin() // 使用自定义的代码压缩插件（覆盖原有策略）, webpack5 默认就是 TerserPlugin
    ]
  }
}
```

**主要是要注意到不是所有的插件都是直接放在 plugins 中的，要根据插件的用途在不同的地方使用**。

#### moduleIds

在 webpack 5 之前，生成的 chunk name，默认是`1.xxxxxx.js`，`2.xxxxx.js`这样的数字 moduleId。如果`2.js`和`1.js`在一个  chunk 内，但是我们现在不使用`1.js`比如临时注释了`1.js`相关的代码，会导致`2.js`的 xxxxx（hash）也改变，即 webpack 常见的**缓存失效问题**。

在 webpack 5 之后，对 moduleId 进行了改进，允许我们配置不同的 id 生成算法，以进行长久的缓存。

| 选项值            | 描述                                                         |
| :---------------- | :----------------------------------------------------------- |
| `'natural'`       | 按使用顺序的数字 id。既不是生产也不是开发环境会被设置成该值。 |
| `'named'`         | 对调试更友好的可读的 id。在开发环境中默认开启。              |
| `'deterministic'` | 在不同的编译中不变的短数字 id。有益于长期缓存。在生产模式中会默认开启。 |
| `'size'`          | 专注于让初始下载包大小更小的数字 id。                        |
| `'total-size'`    | 专注于让总下载包大小更小的数字 id。                          |

```js
modeule.exports = {
  optimization: {
    moduleIds: 'deterministic'
  }
}
```

当我们配置为`deterministic`算法后，即使 chunk 内的其他文件变了，该文件的也不会改变，缓存也就不会失效。

#### [TerserWebpackPlugin](//webpack.docschina.org/plugins/terser-webpack-plugin/)

webpack 内置的 tree-shaking 插件，**如果要自定义配置，仍然需要手动安装该插件** 

详细的配置官方文档：https://github.com/terser/terser#mangle-properties-options

```js
{
  optimization: {
    minimizer: [
      new TerserPlugin({
        test: /.js$/i, /* 执行 tree-shaking 的文件，默认是 js 和 mjs */,
        exclude: /\node_modules/, /* 排除的文件 */,
        terserOptions: { // 插件压缩选项
          // compress: true, // 使用默认压缩函数，也可以配置详细属性
          compress: { // 重要！！！：很多压缩操作是没必要的，却会花费很多时间，可以进行详细设置
            defaults: false, // 默认 true，所有选项的默认值，嫌麻烦可以直接可以关闭大部分配置
            arrows: false, // 箭头函数更短的话转换为箭头函数
            booleans: false, // !!a ? b : c → a ? b : c
            collapse_vars: false, // 合并一次性变量
            comparisons: false, // 转换比较运算符 !(a <= b) -> a > b
            computed_props: false, // 转换计算属性 {['a']: 1} -> {a: 1}
            hoist_funs: false, // 提升函数声明
            hoist_props: false, // 提升属性 var o={p:1, q:2}; f(o.p, o.q) -> f(1, 2);
            if_return: false, // 当if条件只有一个return时，可以移除if
            drop_console: false, // 生产模式默认 true
            inline: false, // 内联函数，将简单函数内联
            loops: false, // 当可以确认静态条件时，优化循环
            negate_iife: false, // 取反立即执行函数
            properties: false, //  foo['bar'] -> foo.bar
            reduce_vars: false, // 合并变量
            reduce_funcs: false, // 合并函数，尽可能内联函数
            sequences: 20, // 转换逗号表达式，使用逗号连接简单的表达式。也可以设置数字表示能连接的最大长度，会很大的影响性能，建议 <= 20
            switches: false, // 去重和删除无法访问的分支
            toplevel: false, // 删除未使用的全局变量
          },
          format: {
            comments: /@keep/ // 保留 /@keep/开头的注释，和 compress 一样可以直接 true 全部保留
          },
          mangle: true // 混淆名称 生产默认 true
        },
        minify: TerserPlugin.swcMinify // 重要！！！：自定义压缩方式
      }),
    ],
  },
};
```

**minimize 会极大的影响性能，在我的项目中实测开和不开，性能差距高达一倍。在启用缓存的情况下高达 10倍。**

在使用分析工具确认时这个配置影响构建速度之后可以对其进行详细的配置以优化。

在**开发环境我们可以关闭此选项**，因为开发环境不需要压缩代码！

**自定义压缩方式：**

配置该插件最简单有效的方式是使用内置的 minify 插件，有以下几种：

1. `TerserPlugin.swcMinify` SWC 编写的 minify 插件，速度是最快的，快的恐怖。需要另外安装`@swc/core`
2. `TerserPlugin.esbuildMinify` 使用 esbuild 来压缩，速度只比 SWC 慢点。需要另外安装`esbuild`
3. `TerserPlugin.uglifyJsMinify` 经典的代码压缩插件，也是最平均代码提及和可读性的一个。需要另外安装`uglifyjs` 

#### splitChunks

webpack 优化分包策略。在 webpack 中存在一系列的自动优化，比如:

- 共享重复依赖，只打包一次
- chunk 大于 20 kb时自动分包
- 按需加载 chunks 时，如果并行请求数量小于或等于 30 自动分包

该功能依赖于内置的`split-chunks-plugin`（在webpack 5 之前是`CommonsChunkPlugin`），常用配置如下

*分包：指单独打包* 

```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'async', // 选择那些配置进行优化，默认是 async 类型的，也可以使用 all / initial。也可以设置为函数接收参数 chunk，使用 chunks.name 来判断
      maxAsyncRequests: 30, // 按需加载的最大并行请求数，默认 30
      cacheGroups: { // 缓存组
        vendors: {
          name: 'chunk-vendors',
          test: /[\\/]node_modules[\\/]/, // 处理 node_modules 里面的
          priority: -10, // 数字越大，优先级越高，当符合两个规则时比如 chunks 都设置 initial，那优先级高的会先执行。自定义的默认 0 
          minChunks: 2, // 模块被引用两次以上才抽离
          chunks: 'initial' // 缓存初始化加载时的模块
        }
      }
    }
  }
}
```

#### runtimeChunk



## stats 统计信息在 shell 的输出控制

官方文档：https://www.webpackjs.com/configuration/stats/

对于 webpack-dev-server，这个属性要放在`devServer` 对象里

```js
module.exports = {
  stats: "none" // 没有输出 
}
```

- minimal：只在有编译或错误信息时输出
- normal：标准输出
- verbose：全部输出

也提供更加详细的控制，可参考官方文档

## parallelism 限制并行文件处理数量

parallelism 配置可以限制 webpack 并行处理的文件数量，默认是 100。但是如果大文件太多，可能会造成内存溢出，就可以减小该值来处理。当然也会减慢构建速度

```js
module.exports = {
  parallelism: 50
}
```

## watch & watchOptions 监听文件变化

在 webpack-dev-server 和 webpack-dev-middleware 中，默认会开启 watch 模式，所以这个配置对我们业务开发来说基本是一直开着的。所以有时候需要对 watchOptions 做一些定制，减少内存占用和提高构建速度。

```js
module.exports = {
  watchOptions: {
    aggregateTimeout: 300, // 重新构建前的延迟，聚合更改。默认是 300 ms
    ignored: /node_modules/, // 忽略监听某些文件，可以减少内存占用
    poll: 1000, // 开启轮询构建，如果监听不生效（比如在虚拟机和nfs盘上）可以使用该选项
  }
}
```



## 其他字段说明

#### hash / fullhash / contenthash / chunhash

在 webpack 5 之前用没有 fullhash 而是 hash，在 webpack 5 之后就用了 fullhash 取代了。推荐现在使用 fullhah，否则会有警告

- hash & fullhash : 故名思义全局 hash，打包出来的所有文件的 fullhash 都是相同的。项目中任意一个文件改变，fullhash 也会跟着变。**注意文件冲突的情况** 
- contenthash: 文件级别的 hash，文件内容改变时才会改变
- chunkhash: chunk 级别的 hash，同一个 chunk 中的 hash 相同。一个 chunk 中任意文件更改时，chunk 内的其他文件的 chunkhash 也会随之改变

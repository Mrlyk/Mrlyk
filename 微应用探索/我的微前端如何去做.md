# 我的微前端如何去做

----

## 一、当前存在的微前端架构

> 微前端的三大特性：无技术栈限制，应用单独开发，多应用整合

### 1、iframe 

> 最基本的微前端解决方案，公司对一些老项目使用的该方案

`iframe` 是`html`提供的标签，**能加载其他web应用的内容**，并且它能兼容所有的浏览器，因此，可以用它来**加载任何想要加载的web应用**。

`iframe` 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。

**ifame 存在的的问题总结**

1. 不是单页应用，会导致浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. 弹框类的功能无法应用到整个大应用中，只能在对应的窗口内展示。
3. 由于可能应用间不是在相同的域内，主应用的 cookie 要透传到根域名都不同的子应用中才能实现**免登录**效果。
4. 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源。
5. 搜索引擎无法获取，seo 无法实现。



### 2、Web Components

> 官方原生的解决方案，github 使用了该方案

MDN 定义：

```text
作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。

Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。
```

**三项主要技术**

- **Custom elements（自定义元素）**：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。
- **Shadow DOM（影子DOM）**：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。
- **HTML templates（HTML模板）**： `<template>` 和 `<slot>` 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。

**使用 `Web Components`实现微前端**

1. **技术栈无关**：`Web Components`是浏览器原生组件，那即是在任何框架中都可以使用。
2. **独立开发**：使用`Web Components`开发的应用无需与其他应用间产生任何关联。
3. **应用间隔离**： `Shadow DOM`的特性，各个引入的微应用间可以达到相互隔离的效果。

**存在的问题**

1. 兼容性问题。
2. 复杂，无论是项目结构还是路由还是数据传输存储，完全要自己手动书写。
3. 只能在把它嵌入现代框架中，而不能把现代框架嵌入其中。



### 3、ESM

> ES2015 新的技术手段。公司目前的一些 mapp 应用使用的该方案

**特点**

1. **无技术栈限制**：`ESM`加载的只是js内容，无论哪个框架，最终都要编译成js，因此，无论哪种框架，`ESM`都能加载。
2. **应用单独开发**： ESM只是js的一种规范，不会影响应用的开发模式。
3. **多应用整合**： 只要将微应用以`ESM`的方式暴露出来，就能正常加载。
4. **远程加载模块**: `ESM`能够直接请求`cdn`资源，这是它与生俱来的能力。

**问题**

1. 兼容性问题。
2. 环境无法隔离，全局环境污染。
3. 热加载存在问题。

### 4、qiankun

> 淘宝的微前端方案

**特点**

- **基于**`single-spa`封装，提供了更加开箱即用的 API
- **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架
- **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单
- **样式隔离**，确保微应用之间样式互相不干扰
- **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突
- **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
- **umi 插件**，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统

待实际构建`demo`使用...

### 5、Webpack 5 和 Module Federation

> Module Federation 是 Zack Jackson 发明的 JavaScript 架构。Webpack 团队提供帮助将该插件引入了 Webpack 5，目前处于 beta 测试阶段。

**一些基本概念**

- 使用Module Federation 时， 每个应用块都是一个独立的构建，这些构建都将被编译为 容器。 
- 被应用的容器，被称为 remote 
- 引用者，被称为 host 
- 暴露出去被使用的模块，称为remote模块

**特点**

- 模块拆解。庞大的应用会面临代码编译速度慢，各个模块迭代快速上线排队等，拆解模块解决问题
- 能力共享 。a 应用写了某种能力，b 应用也需要，常规做法再贴一份做迁移，有了`Module Federation`可直接共享。
- 资源共享。传统的npm共享面临资源同步问题，使`Module Federation`用一键更新。

非常方便的开箱即用，小型项目之间的模块共享可以考虑该方案。



### 6、EMP

> YY 的微前端方案，基于`webpack5 module Federation`[学习文档](https://github.com/efoxTeam/emp/wiki/《module-Federation原理学习》)

**年轻的微前端方案**

**特点**

- **基于**`Webpack5`的新特性`Module Federation`实现，达到**第三方依赖共享，减少不必要的代码引入**的目的，什么是[Module Federation](https://link.zhihu.com/?target=https%3A//juejin.cn/post/6895324456668495880)这里就不再赘述。
- **每个微应用独立部署运行**，并通过cdn的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于`Module Federation`的应用使用。并且此部分代码是远程引入，无需参与应用的打包。
- **动态更新微应用**：`EMP`是通过`cdn`加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。
- **去中心化**，每个微应用间都可以引入其他的微应用，无中心应用的概念。
- **跨技术栈组件式调用**，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅[官方文档](https://link.zhihu.com/?target=https%3A//github.com/efoxTeam/emp/blob/main/README-zh_CN.md)）。
- **按需加载**，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载。
- **应用间通信**，每一个应用都可以进行状态共享，就像在使用npm模块进行开发一样便捷。
- **生成对应技术栈模板**，它能像`cerate-react-app`一样，也能像`create-vue-app`一样，通过指令一键搭建好开发环境，减少开发者的负担。
- **远程拉取ts声明文件**，`emp-cli`中内置了拉取远程应用中代码声明文件的能力，让使用ts开发的开发者不再为代码报错而烦恼。

相对于其他框架实现了**跨应用状态共享**、**跨框架组件调用**的能力。



### 二、业界的微前端方案

- **NPM式**：子工程以NPM包的形式发布源码；打包构建发布还是由基座工程管理，打包时集成。
- **iframe式**：子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；基座工程和子工程需要建立通信机制；无单页应用体验；路由地址管理困难。
- **通用中心路由基座式**：子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；统一由基座工程进行管理，按照DOM节点的注册、挂载、卸载来完成。
- **特定中心路由基座式**：子业务线之间使用相同技术栈；基座工程和子工程可以单独开发单独部署；子工程有能力复用基座工程的公共基建。

通过对各个方案特点进行分析，我们将重点关注项进行了对比，如下表所示：

| 方案                   | 技术栈是否能统一 | 单独打包 | 单独部署 | 打包部署速度 | 单页应用体验 | 子工程切换速度 | 工程间通信难度 | 现有工程侵入性 | 学习成本 |
| :--------------------- | :--------------- | :------- | :------- | :----------- | :----------- | :------------- | :------------- | :------------- | :------- |
| **NPM式**              | 是（不强制）     | 否       | 否       | 慢           | 是           | 快             | 正常           | 高             | 高       |
| **iframe式**           | 是（不强制）     | 是       | 是       | 正常         | 否           | 慢             | 高             | 高             | 低       |
| **通用中心路由基座式** | 是（不强制）     | 是       | 是       | 正常         | 是           | 慢             | 高             | 高             | 高       |
| **特定中心路由基座式** | 是（强制）       | 是       | 是       | 快           | 是           | 快             | 正常           | 低             | 低       |